{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"\u672c\u6a21\u677f\u4e13\u4e3aACM\u7ade\u8d5b\u53ca\u5b66\u4e60\u4f7f\u7528","title":"\u7b80\u4ecb"},{"location":"about/","text":"\u8054\u7cfb\u4eba: \u4ea6\u5f80\u6ca7\u52ab","title":"\u5173\u4e8e"},{"location":"\u5176\u4ed6\u6280\u5de7/\u535a\u5f08\u8bba/","text":"Nim\u6e38\u620f \u00b6 No.1 \u6709N\u5806\u77f3\u5b50\u3002A B\u4e24\u4e2a\u4eba\u8f6e\u6d41\u62ff\uff0cA\u5148\u62ff\u3002\u6bcf\u6b21\u53ea\u80fd\u4ece\u4e00\u5806\u4e2d\u53d6\u82e5\u5e72\u4e2a\uff0c\u53ef\u5c06\u4e00\u5806\u5168\u53d6\u8d70\uff0c\u4f46\u4e0d\u53ef\u4e0d\u53d6\uff0c\u62ff\u5230\u6700\u540e1\u9897\u77f3\u5b50\u7684\u4eba\u83b7\u80dc\u3002\u7ed9\u51faN\u53ca\u6bcf\u5806\u77f3\u5b50\u7684\u6570\u91cf\uff0c\u95ee\u6700\u540e\u8c01\u80fd\u8d62\u5f97\u6bd4\u8d5b\u3002 1 a [ 1 ]^ a [ 2 ]^ ... ^ a [ N ]== 0 ? \"B\" : \"A\" ; Bash\u6e38\u620f \u00b6 No.1 \u6709\u4e00\u5806\u77f3\u5b50\u5171\u6709N\u4e2a\u3002A B\u4e24\u4e2a\u4eba\u8f6e\u6d41\u62ff\uff0cA\u5148\u62ff\u3002\u6bcf\u6b21\u6700\u5c11\u62ff1\u9897\uff0c\u6700\u591a\u62ffK\u9897\uff0c\u62ff\u5230\u6700\u540e1\u9897\u77f3\u5b50\u7684\u4eba\u83b7\u80dc\u3002\u7ed9\u51faN\u548cK\uff0c\u95ee\u6700\u540e\u8c01\u80fd\u8d62\u5f97\u6bd4\u8d5b\u3002 1 2 if ( N % ( K + 1 )) cout << \"A\" << endl ; else cout << \"B\" << endl ; No.2 \u6709\u4e00\u5806\u77f3\u5b50\u5171\u6709N\u4e2a\u3002A B\u4e24\u4e2a\u4eba\u8f6e\u6d41\u62ff\uff0cA\u5148\u62ff\u3002\u6bcf\u6b21\u53ea\u80fd\u62ff1\uff0c3\uff0c4\u9897\uff0c\u62ff\u5230\u6700\u540e1\u9897\u77f3\u5b50\u7684\u4eba\u83b7\u80dc\u3002\u7ed9\u51faN\uff0c\u95ee\u6700\u540e\u8c01\u80fd\u8d62\u5f97\u6bd4\u8d5b\u3002 1 2 if ( N % 7 == 0 || N % 7 == 2 ) cout << \"B\" << endl ; else cout << \"A\" << endl ; No.3* \u6709\u4e00\u5806\u77f3\u5b50\u5171\u6709N\u4e2a\u3002A B\u4e24\u4e2a\u4eba\u8f6e\u6d41\u62ff\uff0cA\u5148\u62ff\u3002\u6bcf\u6b21\u62ff\u7684\u6570\u91cf\u53ea\u80fd\u662f2\u7684\u6b63\u6574\u6570\u6b21\u5e42\uff0c\u6bd4\u5982(1,2,4,8,16....)\uff0c\u62ff\u5230\u6700\u540e1\u9897\u77f3\u5b50\u7684\u4eba\u83b7\u80dc\u3002\u7ed9\u51faN\uff0c\u95ee\u6700\u540e\u8c01\u80fd\u8d62\u5f97\u6bd4\u8d5b\u3002 1 2 if ( N % 3 ) cout << \"A\" << endl ; else cout << \"B\" << endl ; NO.4 \u6709\u4e00\u5806\u77f3\u5b50\u5171\u6709N\u4e2a\u3002A B\u4e24\u4e2a\u4eba\u8f6e\u6d41\u62ff\uff0cA\u5148\u62ff\u3002\u6bcf\u6b21\u62ff\u7684\u6570\u91cf\u6700\u5c111\u4e2a\uff0c\u6700\u591a\u4e0d\u8d85\u8fc7\u5bf9\u624b\u4e0a\u4e00\u6b21\u62ff\u7684\u6570\u91cf\u76842\u500d\uff08A\u7b2c1\u6b21\u62ff\u65f6\u8981\u6c42\u4e0d\u80fd\u5168\u62ff\u8d70\uff09\u3002\u62ff\u5230\u6700\u540e1\u9897\u77f3\u5b50\u7684\u4eba\u83b7\u80dc\u3002\u7ed9\u51faN\uff0c\u95ee\u6700\u540e\u8c01\u80fd\u8d62\u5f97\u6bd4\u8d5b\u3002 1 2 if ( fibonacci ( N )) cout << \"B\" << endl ; else cout << \"A\" << endl ; \u5a01\u4f50\u592b\u6e38\u620f \u00b6 No.1 \u67092\u5806\u77f3\u5b50\u3002A B\u4e24\u4e2a\u4eba\u8f6e\u6d41\u62ff\uff0cA\u5148\u62ff\u3002\u6bcf\u6b21\u53ef\u4ee5\u4ece\u4e00\u5806\u4e2d\u53d6\u4efb\u610f\u4e2a\u6216\u4ece2\u5806\u4e2d\u53d6\u76f8\u540c\u6570\u91cf\u7684\u77f3\u5b50\uff0c\u4f46\u4e0d\u53ef\u4e0d\u53d6\u3002\u62ff\u5230\u6700\u540e1\u9897\u77f3\u5b50\u7684\u4eba\u83b7\u80dc\u3002\u7ed9\u51fa2\u5806\u77f3\u5b50\u7684\u6570\u91cf\uff0c\u95ee\u6700\u540e\u8c01\u80fd\u8d62\u5f97\u6bd4\u8d5b\u3002 1 2 if (( b - a ) * ( sqrt ( 5 ) + 1 ) / 2 == a ) cout << \"B\" << endl ; else cout << \"A\" << endl ; //b>a","title":"\u535a\u5f08\u8bba"},{"location":"\u5176\u4ed6\u6280\u5de7/\u535a\u5f08\u8bba/#nim","text":"No.1 \u6709N\u5806\u77f3\u5b50\u3002A B\u4e24\u4e2a\u4eba\u8f6e\u6d41\u62ff\uff0cA\u5148\u62ff\u3002\u6bcf\u6b21\u53ea\u80fd\u4ece\u4e00\u5806\u4e2d\u53d6\u82e5\u5e72\u4e2a\uff0c\u53ef\u5c06\u4e00\u5806\u5168\u53d6\u8d70\uff0c\u4f46\u4e0d\u53ef\u4e0d\u53d6\uff0c\u62ff\u5230\u6700\u540e1\u9897\u77f3\u5b50\u7684\u4eba\u83b7\u80dc\u3002\u7ed9\u51faN\u53ca\u6bcf\u5806\u77f3\u5b50\u7684\u6570\u91cf\uff0c\u95ee\u6700\u540e\u8c01\u80fd\u8d62\u5f97\u6bd4\u8d5b\u3002 1 a [ 1 ]^ a [ 2 ]^ ... ^ a [ N ]== 0 ? \"B\" : \"A\" ;","title":"Nim\u6e38\u620f"},{"location":"\u5176\u4ed6\u6280\u5de7/\u535a\u5f08\u8bba/#bash","text":"No.1 \u6709\u4e00\u5806\u77f3\u5b50\u5171\u6709N\u4e2a\u3002A B\u4e24\u4e2a\u4eba\u8f6e\u6d41\u62ff\uff0cA\u5148\u62ff\u3002\u6bcf\u6b21\u6700\u5c11\u62ff1\u9897\uff0c\u6700\u591a\u62ffK\u9897\uff0c\u62ff\u5230\u6700\u540e1\u9897\u77f3\u5b50\u7684\u4eba\u83b7\u80dc\u3002\u7ed9\u51faN\u548cK\uff0c\u95ee\u6700\u540e\u8c01\u80fd\u8d62\u5f97\u6bd4\u8d5b\u3002 1 2 if ( N % ( K + 1 )) cout << \"A\" << endl ; else cout << \"B\" << endl ; No.2 \u6709\u4e00\u5806\u77f3\u5b50\u5171\u6709N\u4e2a\u3002A B\u4e24\u4e2a\u4eba\u8f6e\u6d41\u62ff\uff0cA\u5148\u62ff\u3002\u6bcf\u6b21\u53ea\u80fd\u62ff1\uff0c3\uff0c4\u9897\uff0c\u62ff\u5230\u6700\u540e1\u9897\u77f3\u5b50\u7684\u4eba\u83b7\u80dc\u3002\u7ed9\u51faN\uff0c\u95ee\u6700\u540e\u8c01\u80fd\u8d62\u5f97\u6bd4\u8d5b\u3002 1 2 if ( N % 7 == 0 || N % 7 == 2 ) cout << \"B\" << endl ; else cout << \"A\" << endl ; No.3* \u6709\u4e00\u5806\u77f3\u5b50\u5171\u6709N\u4e2a\u3002A B\u4e24\u4e2a\u4eba\u8f6e\u6d41\u62ff\uff0cA\u5148\u62ff\u3002\u6bcf\u6b21\u62ff\u7684\u6570\u91cf\u53ea\u80fd\u662f2\u7684\u6b63\u6574\u6570\u6b21\u5e42\uff0c\u6bd4\u5982(1,2,4,8,16....)\uff0c\u62ff\u5230\u6700\u540e1\u9897\u77f3\u5b50\u7684\u4eba\u83b7\u80dc\u3002\u7ed9\u51faN\uff0c\u95ee\u6700\u540e\u8c01\u80fd\u8d62\u5f97\u6bd4\u8d5b\u3002 1 2 if ( N % 3 ) cout << \"A\" << endl ; else cout << \"B\" << endl ; NO.4 \u6709\u4e00\u5806\u77f3\u5b50\u5171\u6709N\u4e2a\u3002A B\u4e24\u4e2a\u4eba\u8f6e\u6d41\u62ff\uff0cA\u5148\u62ff\u3002\u6bcf\u6b21\u62ff\u7684\u6570\u91cf\u6700\u5c111\u4e2a\uff0c\u6700\u591a\u4e0d\u8d85\u8fc7\u5bf9\u624b\u4e0a\u4e00\u6b21\u62ff\u7684\u6570\u91cf\u76842\u500d\uff08A\u7b2c1\u6b21\u62ff\u65f6\u8981\u6c42\u4e0d\u80fd\u5168\u62ff\u8d70\uff09\u3002\u62ff\u5230\u6700\u540e1\u9897\u77f3\u5b50\u7684\u4eba\u83b7\u80dc\u3002\u7ed9\u51faN\uff0c\u95ee\u6700\u540e\u8c01\u80fd\u8d62\u5f97\u6bd4\u8d5b\u3002 1 2 if ( fibonacci ( N )) cout << \"B\" << endl ; else cout << \"A\" << endl ;","title":"Bash\u6e38\u620f"},{"location":"\u5176\u4ed6\u6280\u5de7/\u535a\u5f08\u8bba/#_1","text":"No.1 \u67092\u5806\u77f3\u5b50\u3002A B\u4e24\u4e2a\u4eba\u8f6e\u6d41\u62ff\uff0cA\u5148\u62ff\u3002\u6bcf\u6b21\u53ef\u4ee5\u4ece\u4e00\u5806\u4e2d\u53d6\u4efb\u610f\u4e2a\u6216\u4ece2\u5806\u4e2d\u53d6\u76f8\u540c\u6570\u91cf\u7684\u77f3\u5b50\uff0c\u4f46\u4e0d\u53ef\u4e0d\u53d6\u3002\u62ff\u5230\u6700\u540e1\u9897\u77f3\u5b50\u7684\u4eba\u83b7\u80dc\u3002\u7ed9\u51fa2\u5806\u77f3\u5b50\u7684\u6570\u91cf\uff0c\u95ee\u6700\u540e\u8c01\u80fd\u8d62\u5f97\u6bd4\u8d5b\u3002 1 2 if (( b - a ) * ( sqrt ( 5 ) + 1 ) / 2 == a ) cout << \"B\" << endl ; else cout << \"A\" << endl ; //b>a","title":"\u5a01\u4f50\u592b\u6e38\u620f"},{"location":"\u5176\u4ed6\u6280\u5de7/pb_ds/\u5e73\u8861\u6811/","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 #include <bits/stdc++.h> #include <ext/pb_ds/tree_policy.hpp> #include <ext/pb_ds/assoc_container.hpp> using namespace __gnu_pbds ; using namespace std ; typedef long long ll ; tree < ll , null_type , less < ll > , rb_tree_tag , tree_order_statistics_node_update > bbt ; //tree<ll,null_type,less<ll>,splay_tree_tag,tree_order_statistics_node_update>bbt; //tree<ll,null_type,less<ll>,ov_tree_tag,tree_order_statistics_node_update>bbt; /* int\u7c7b\u578b null_type\u4e3a\u6620\u5c04\u7c7b\u578b, \u4f4e\u7248\u672cg++\u4e3a null_mapped_type less<int>, greater<int> \u6bd4\u8f83\u5668 rb_tree_tag \u548c splay_tree_tag \u9009\u62e9\u6811\u7684\u7c7b\u578b tree_order_statistics_node_update \u7ed3\u70b9\u66f4\u65b0 insert, erase order_of_key rank find_by_order() kth lower_bound() \u524d\u7ee7\uff0c >=x \u6700\u5c0f\u7684\u8fed\u4ee3\u5668 upper_bound() \u540e\u7ee7 >x \u6700\u5c0f\u7684\u8fed\u4ee3\u5668 a.join(b) b\u5e76\u5165a\uff0c\u524d\u63d0\u662f\u4e24\u9897\u6811\u7684\u53d6\u503c\u8303\u56f4\u4e0d\u76f8\u4ea4 a.split(v, b) key <= v\u7684\u5c5e\u4e8ea\uff0c\u5176\u4ed6\u5c5e\u4e8e \u6ce8\u610f\uff0c\u63d2\u5165\u7684\u5143\u7d20\u4f1a\u53bb\u91cd\uff0c\u5982set */ int main (){ ll T , op , n ; cin >> T ; for ( int i = 1 ; i <= T ; i ++ ){ cin >> op >> n ; if ( op == 1 ){ bbt . insert (( n << 20 ) + i ); } else if ( op == 2 ){ bbt . erase ( bbt . lower_bound ( n << 20 )); } else if ( op == 3 ){ cout << bbt . order_of_key ( n << 20 ) + 1 << endl ;; } else if ( op == 4 ){ cout << (( * bbt . find_by_order ( n - 1 )) >> 20 ) << endl ; } else if ( op == 5 ){ cout << (( *-- bbt . lower_bound ( n << 20 )) >> 20 ) << endl ; } else { cout << (( * bbt . lower_bound (( n + 1 ) << 20 )) >> 20 ) << endl ; } } return 0 ; }","title":"\u5e73\u8861\u6811"},{"location":"\u5176\u4ed6\u6280\u5de7/\u9ad8\u7cbe\u5ea6/\u4e58\u6cd5/","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include <bit/stdc++.h> using namespace std ; int main () { string a , b ; int cnt [ 2020 ]; memset ( cnt , 0 , sizeof ( cnt )); cin >> a >> b ; for ( int i = 0 ; i < a . length (); i ++ ) for ( int j = 0 ; j < b . length (); j ++ ) cnt [ i + j ] += ( a [ i ] - '0' ) * ( b [ j ] - '0' ); for ( int i = a . length () + b . length (); i > 0 ; i -- ) cnt [ i - 1 ] += cnt [ i ] / 10 , cnt [ i ] %= 10 ; for ( int i = 0 ; i < a . length () + b . length () - 1 ; i ++ ) cout << cnt [ i ]; cout << endl ; return 0 ; }","title":"\u4e58\u6cd5"},{"location":"\u5176\u4ed6\u6280\u5de7/\u9ad8\u7cbe\u5ea6/\u9636\u4e58/","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 #include <bits/stdc++.h> #define mod 100000000000000 typedef long long ll ; using namespace std ; ll ans [ 10000000 ]; int main () { int N ; ll t , s , l = 0 ; //l\u8bb0\u5f55\u7ed3\u679c\u6240\u5360\u6570\u7ec4\u957f\u5ea6 cin >> N ; ans [ 0 ] = 1 ; for ( int i = 2 ; i <= N ; i ++ ) { s = 0 ; //s\u5b58\u50a8\u8d85\u8fc714\u4f4d\u7684\u90e8\u5206 for ( int j = 0 ; j <= l ; j ++ ) { t = ans [ j ] * i + s ; ans [ j ] = t % mod ; s = t / mod ; } if ( s ) ans [ ++ l ] = s ; } printf ( \"%lld\" , ans [ l ]); //\u5355\u72ec\u8f93\u51fa\u6d88\u53bb\u524d\u7f000 for ( int i = l - 1 ; i >= 0 ; i -- ) printf ( \"%014lld\" , ans [ i ]); //\u4e4b\u540e\u7684\u5c31\u8981\u4e25\u683c\u630914\u4f4d\u8f93\u51fa printf ( \" \\n \" ); return 0 ; }","title":"\u9636\u4e58"},{"location":"\u52a8\u6001\u89c4\u5212/\u52a8\u6001\u89c4\u5212\u521d\u6b65/","text":"No.1 (\u6700\u957f\u9012\u589e\u5b50\u5e8f\u5217) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 #include <bits/stdc++.h> using namespace std ; int dp [ 50020 ]; int main () { int N , a [ 50020 ]; cin >> N ; for ( int i = 0 ; i < N ; i ++ ) cin >> a [ i ]; dp [ 0 ] = 1 ; for ( int i = 1 ; i < N ; i ++ ) { dp [ i ] = 1 ; for ( int j = 0 ; j < i ; j ++ ) { if ( a [ i ] > a [ j ]) dp [ i ] = max ( dp [ j ] + 1 , dp [ i ]); } } int maxx =- 0x3f ; for ( int i = 1 ; i < N ; i ++ ) { if ( dp [ i ] > maxx ) maxx = dp [ i ]; } cout << maxx << endl ; return 0 ; } No.2 (\u7f16\u8f91\u8ddd\u79bb) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 #include <iostream> #include <cstring> #include <cmath> using namespace std ; string a , b , t ; int dp [ 1020 ][ 1020 ]; int main () { cin >> a >> b ; int n = a . length (); int m = b . length (); memset ( dp , 0 , sizeof ( dp )); for ( int i = 0 ; i <= max ( n , m ); i ++ ) dp [ 0 ][ i ] = dp [ i ][ 0 ] = i ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= m ; j ++ ) { if ( a [ i - 1 ] == b [ j - 1 ]) dp [ i ][ j ] = dp [ i - 1 ][ j - 1 ]; else dp [ i ][ j ] = dp [ i - 1 ][ j - 1 ] + 1 ; dp [ i ][ j ] = min ( min ( dp [ i - 1 ][ j ], dp [ i ][ j - 1 ]) + 1 , dp [ i ][ j ]); } } cout << dp [ n ][ m ] << endl ; return 0 ; } No.3 (\u6700\u957f\u516c\u5171\u5b50\u5e8f\u5217LCS) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 #include <bits/stdc++.h> using namespace std ; int LCS [ 1020 ][ 1020 ], mark [ 1020 ][ 1020 ]; string s1 , s2 , s , ans ; void output ( int x , int y ) { if ( x <= 0 || y <= 0 ) return ; else if ( mark [ x ][ y ] == 1 ) { output ( x - 1 , y - 1 ); cout << s1 [ x - 1 ]; } else if ( mark [ x ][ y ] ==- 1 ) output ( x - 1 , y ); else output ( x , y - 1 ); } int main () { cin >> s1 >> s2 ; for ( int i = 0 ; i <= s1 . length (); i ++ ) { for ( int j = 0 ; j <= s2 . length (); j ++ ) { if ( i == 0 ) { LCS [ i ][ j ] = 0 ; mark [ i ][ j ] =- 1 ; } else if ( j == 0 ) { LCS [ i ][ j ] = 0 ; mark [ i ][ j ] = 0 ; } else if ( s1 [ i - 1 ] == s2 [ j - 1 ]) { LCS [ i ][ j ] = LCS [ i - 1 ][ j - 1 ] + 1 ; mark [ i ][ j ] = 1 ; } else { if ( LCS [ i - 1 ][ j ] > LCS [ i ][ j - 1 ]) { LCS [ i ][ j ] = LCS [ i - 1 ][ j ]; mark [ i ][ j ] =- 1 ; } else { LCS [ i ][ j ] = LCS [ i ][ j - 1 ]; mark [ i ][ j ] = 0 ; } } } } output ( s1 . length (), s2 . length ()); cout << endl ; return 0 ; } No.4 (\u6700\u5927\u5b50\u77e9\u9635\u548c) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 #include <bits/stdc++.h> typedef long long ll ; using namespace std ; ll sum , a [ 520 ][ 520 ], dp [ 520 ]; ll N , M , mas =- 1 , temp ; ll maxsub () { ll mas = 0 , t = 0 ; for ( int i = 0 ; i < M ; i ++ ) { if ( t > 0 ) t += dp [ i ]; else t = dp [ i ]; if ( t > mas ) mas = t ; } return mas ; } int main () { cin >> M >> N ; for ( int i = 0 ; i < N ; i ++ ) for ( int j = 0 ; j < M ; j ++ ) cin >> a [ i ][ j ]; for ( int i = 0 ; i < N ; i ++ ) { memset ( dp , 0 , sizeof ( dp )); for ( int j = i ; j < N ; j ++ ) { for ( int k = 0 ; k < M ; k ++ ) dp [ k ] += a [ j ][ k ]; temp = maxsub (); if ( temp > mas ) mas = temp ; } } if ( mas >= 0 ) cout << mas << endl ; else cout << 0 << endl ; return 0 ; }","title":"\u52a8\u6001\u89c4\u5212\u521d\u6b65"},{"location":"\u52a8\u6001\u89c4\u5212/\u80cc\u5305\u4e5d\u8bb2/01\u80cc\u5305/","text":"No.1 (\u4e00\u7ef4\u6570\u7ec4) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #include <bits/stdc++.h> using namespace std ; int N , W , a [ 120 ], b [ 120 ], dp [ 10020 ]; int main () { cin >> N >> W ; for ( int i = 1 ; i <= N ; i ++ ) cin >> a [ i ] >> b [ i ]; memset ( dp , 0 , sizeof ( dp )); for ( int i = 1 ; i <= N ; i ++ ) { for ( int j = W ; j >= a [ i ]; j -- ) dp [ j ] = max ( dp [ j ], dp [ j - a [ i ]] + b [ i ]); } cout << dp [ W ] << endl ; return 0 ; } No.2 (\u4e8c\u7ef4\u6570\u7ec4) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #include <bits/stdc++.h> using namespace std ; int N , W , a [ 120 ], b [ 120 ], dp [ 120 ][ 10020 ]; int main () { cin >> N >> W ; for ( int i = 1 ; i <= N ; i ++ ) cin >> a [ i ] >> b [ i ]; memset ( dp , 0 , sizeof ( dp )); for ( int i = 1 ; i <= N ; i ++ ) { for ( int j = 1 ; j <= W ; j ++ ) { if ( j < a [ i ]) dp [ i ][ j ] = dp [ i - 1 ][ j ]; else dp [ i ][ j ] = max ( dp [ i - 1 ][ j ], dp [ i - 1 ][ j - a [ i ]] + b [ i ]); } } cout << dp [ N ][ W ] << endl ; return 0 ; } No.3 (\u9650\u5b9a\u6570\u91cf) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 #include <bits/stdc++.h> using namespace std ; int main () { int n , m , s , a [ 60 ], dp [ 1020 ]; while ( cin >> n >> m >> s ) { memset ( dp , 0 , sizeof ( dp )); dp [ 0 ] = 1 ; for ( int i = 0 ; i < m ; i ++ ) cin >> a [ i ]; for ( int i = 0 ; i < m ; i ++ ) { for ( int j = s ; j >= a [ i ]; j -- ) { if ( dp [ j - a [ i ]]) { if ( ! dp [ j ] && j == a [ i ]) dp [ j ] = 1 ; else if ( ! dp [ j ] || dp [ j ] >= dp [ j - a [ i ]]) dp [ j ] = dp [ j - a [ i ]] + 1 ; } } } for ( int i = s ; i >= 0 ; i -- ) { if ( dp [ i ] && dp [ i ] <= n ) { cout << i << endl ; break ; } } } return 0 ; }","title":"01\u80cc\u5305"},{"location":"\u56fe\u8bba/\u751f\u6210\u6811/Dijkstra/","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 #include <bits/stdc++.h> #define INF 0x3f3f3f3f typedef long long ll ; using namespace std ; int cost [ 120 ][ 120 ], d [ 120 ], V , M ; bool vis [ 120 ]; void dijkstra ( int s ) { fill ( d , d + 120 , INF ); fill ( vis , vis + 120 , false ); d [ s ] = 0 ; while ( true ) { int v =- 1 ; for ( int u = 1 ; u <= V ; u ++ ) if ( ! vis [ u ] && ( v ==- 1 || d [ u ] < d [ v ])) v = u ; if ( v ==- 1 ) break ; vis [ v ] = true ; for ( int u = 1 ; u <= V ; u ++ ) if ( ! vis [ u ]) d [ u ] = min ( d [ u ], d [ v ] + cost [ v ][ u ]); } } int main () { while ( cin >> V >> M ) { if ( ! V &&! M ) break ; memset ( cost , INF , sizeof ( cost )); int a , b , c ; for ( int i = 0 ; i < M ; i ++ ) { cin >> a >> b >> c ; cost [ a ][ b ] = c ; cost [ b ][ a ] = c ; } dijkstra ( 1 ); cout << d [ V ] << endl ; } return 0 ; }","title":"Dijkstra"},{"location":"\u56fe\u8bba/\u751f\u6210\u6811/Kruskal/","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 #include <bits/stdc++.h> #define INF 0x3f3f3f3f typedef long long ll ; using namespace std ; struct edge { int u , v , cost ;}; bool cmp ( const edge & e1 , const edge & e2 ){ return e1 . cost < e2 . cost ; } edge es [ 50020 ]; int V , E ; //\u9876\u70b9\u6570\u548c\u8fb9\u6570 int par [ 1020 ]; //\u7236\u4eb2 int rank [ 1020 ]; //\u6811\u7684\u9ad8\u5ea6 //\u521d\u59cb\u5316V\u4e2a\u5143\u7d20 void init () { for ( int i = 0 ; i < V ; i ++ ) { par [ i ] = i ; rank [ i ] = 0 ; } } //\u67e5\u8be2\u6811\u7684\u6839 int find ( int x ) { if ( par [ x ] == x ) return x ; return par [ x ] = find ( par [ x ]); } //\u5408\u5e76x\u548cy\u6240\u5c5e\u7684\u96c6\u5408 void unite ( int x , int y ) { x = find ( x ); y = find ( y ); if ( x == y ) return ; if ( rank [ x ] < rank [ y ]) par [ x ] = y ; else { par [ y ] = x ; if ( rank [ x ] == rank [ y ]) rank [ x ] ++ ; } } //\u5224\u65adx\u548cy\u662f\u5426\u5c5e\u4e8e\u540c\u4e00\u4e2a\u96c6\u5408 bool same ( int x , int y ) { return find ( x ) == find ( y ); } int kruskal () { sort ( es , es + E , cmp ); //\u6309\u7167edge,cost\u7684\u987a\u5e8f\u4ece\u5927\u5230\u5c0f init (); //\u5e76\u67e5\u96c6\u7684\u521d\u59cb\u5316 int res = 0 ; for ( int i = 0 ; i < E ; i ++ ) { edge e = es [ i ]; if ( ! same ( e . u , e . v )) { unite ( e . u , e . v ); res += e . cost ; } } return res ; } int main () { cin >> V >> E ; for ( int i = 0 ; i < E ; i ++ ) cin >> es [ i ]. u >> es [ i ]. v >> es [ i ]. cost ; cout << kruskal () << endl ; return 0 ; }","title":"Kruskal"},{"location":"\u56fe\u8bba/\u751f\u6210\u6811/Prim/","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 #include <bits/stdc++.h> #define INF 0x3f3f3f3f typedef long long ll ; using namespace std ; int cost [ 1020 ][ 1020 ]; //cost[u][v]\u8868\u793a\u8fb9e=(u,v)\u7684\u6743\u503c int mincost [ 1020 ]; //\u4ece\u96c6\u5408X\u51fa\u53d1\u7684\u8fb9\u5230\u6bcf\u4e2a\u9876\u70b9\u7684\u6700\u5c0f\u6743\u503c bool used [ 1020 ]; //\u9876\u70b9i\u662f\u5426\u5305\u542b\u5728\u96c6\u5408X\u4e2d int N , M , S , E , W ; int prime () { for ( int i = 1 ; i <= N ; i ++ ) { mincost [ i ] = INF ; used [ i ] = false ; } mincost [ 1 ] = 0 ; int res = 0 ; while ( true ) { int v =- 1 ; //\u4ece\u4e0d\u5c5e\u4e8eX\u7684\u9876\u70b9\u4e2d\u9009\u53d6\u4eceX\u5230\u5176\u6743\u503c\u6700\u5c0f\u7684\u9876\u70b9 for ( int u = 1 ; u <= N ; u ++ ) { if ( ! used [ u ] && ( v ==- 1 || mincost [ u ] < mincost [ v ])) v = u ; } if ( v ==- 1 ) break ; used [ v ] = true ; //\u628a\u9876\u70b9v\u52a0\u5165X res += mincost [ v ]; //\u628a\u8fb9\u7684\u957f\u5ea6\u52a0\u5230\u7ed3\u679c\u91cc for ( int u = 1 ; u <= N ; u ++ ) mincost [ u ] = min ( mincost [ u ], cost [ v ][ u ]); } return res ; } int main () { cin >> N >> M ; memset ( cost , INF , sizeof ( cost )); for ( int i = 0 ; i < M ; i ++ ) { cin >> S >> E >> W ; cost [ S ][ E ] = min ( W , cost [ S ][ E ]); cost [ E ][ S ] = min ( W , cost [ E ][ S ]); } cout << prime () << endl ; return 0 ; }","title":"Prim"},{"location":"\u57fa\u7840\u7b97\u6cd5/\u9012\u63a8/","text":"No.1 (\u94b1\u5e01\u5151\u6362) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include <iostream> typedef long long ll ; using namespace std ; ll dp [ 32800 ]; void init () { dp [ 0 ] = 1 ; for ( int i = 1 ; i <= 3 ; i ++ ) { for ( int j = i ; j <= 32768 ; j ++ ) dp [ j ] += dp [ j - i ]; } } int main () { int N ; init (); while ( cin >> N ) cout << dp [ N ] << endl ; return 0 ; } No.2 (\u7ea6\u745f\u592b\u73af) 1 2 3 4 5 6 7 8 9 10 11 12 13 #include <iostream> using namespace std ; int m [ 1000020 ]; int main () { int N , K ; cin >> N >> K ; m [ 1 ] = 0 ; for ( int i = 2 ; i <= N ; i ++ ) m [ i ] = ( m [ i - 1 ] + K ) % i ; cout << m [ N ] + 1 << endl ; return 0 ; }","title":"\u9012\u63a8"},{"location":"\u5b57\u7b26\u4e32/KMP/","text":"No.1 (\u5e8f\u5217) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 #include <bit/stdc++.h> using namespace std ; int a [ 1000020 ]; int r [ 1000020 ]; int b [ 1000020 ]; int s [ 1000020 ]; int Next [ 1000020 ]; void get ( int * p , int l ) { int i = 0 , j = - 1 ; Next [ i ] = j ; while ( i < l ) { while ( j != - 1 && s [ i ] != s [ j ]) j = Next [ j ]; Next [ ++ i ] = ++ j ; } } int kmp ( int n , int m ) //kmp\u5339\u914d { get ( b , m ); int i = 0 , j = 0 ; int ans = 0 ; while ( i < n ){ while ( j != - 1 && s [ j ] != r [ i ]) j = Next [ j ]; i ++ , j ++ ; if ( j == m - 1 ) ans ++ ; } return ans ; } int main () { int n , m , t ; cin >> n >> m ; for ( int i = 0 ; i < n ; i ++ ) { cin >> a [ i ]; if ( i ) r [ i - 1 ] = a [ i ] - a [ i - 1 ]; //\u628a\u8f93\u5165\u8f6c\u6362\u4e3a\u6bcf\u4e00\u9879\u4e0e\u524d\u4e00\u9879\u7684\u5dee\u503c } for ( int i = 0 ; i < m ; i ++ ) { cin >> b [ i ]; if ( i ) s [ i - 1 ] = b [ i ] - b [ i - 1 ]; //\u540c\u4e0a } cout << kmp ( n , m ) << endl ; return 0 ; } No.2 (\u9012\u5f52\u8f93\u51fa\u540e\u7f00\u957f\u5ea6) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 #include <bit/stdc++.h> using namespace std ; int Next [ 400020 ]; void get ( string s ) { int i = 0 , j =- 1 ; Next [ i ] = j ; while ( i < s . length ()) { if ( j ==- 1 || s [ i ] == s [ j ]) Next [ ++ i ] =++ j ; else j = Next [ j ]; } } void print ( int n ) { if ( n == 0 ) return ; print ( Next [ n ]); cout << n << ' ' ; } int main () { string s ; while ( cin >> s ) { get ( s ); print ( Next [ s . length ()]); cout << s . length () << endl ; } return 0 ; }","title":"KMP"},{"location":"\u6392\u5e8f/\u5f52\u5e76\u6392\u5e8f/","text":"No.1 (\u9006\u5e8f\u6570) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 #include <bits/stdc++.h> typedef long long ll ; using namespace std ; ll sum , a [ 520 ][ 520 ], dp [ 520 ]; ll N , M , mas =- 1 , temp ; ll maxsub () { ll mas = 0 , t = 0 ; for ( int i = 0 ; i < M ; i ++ ) { if ( t > 0 ) t += dp [ i ]; else t = dp [ i ]; if ( t > mas ) mas = t ; } return mas ; } int main () { cin >> M >> N ; for ( int i = 0 ; i < N ; i ++ ) for ( int j = 0 ; j < M ; j ++ ) cin >> a [ i ][ j ]; for ( int i = 0 ; i < N ; i ++ ) { memset ( dp , 0 , sizeof ( dp )); for ( int j = i ; j < N ; j ++ ) { for ( int k = 0 ; k < M ; k ++ ) dp [ k ] += a [ j ][ k ]; temp = maxsub (); if ( temp > mas ) mas = temp ; } } if ( mas >= 0 ) cout << mas << endl ; else cout << 0 << endl ; return 0 ; }","title":"\u5f52\u5e76\u6392\u5e8f"},{"location":"\u6392\u5e8f/\u5feb\u901f\u6392\u5e8f/","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 #include <bits/stdc++.h> using namespace std ; void quick_sort ( int * a , int left , int right ) { if ( left >= right ) return ; swap ( a [ left ], a [( left + right ) / 2 ]); int i = left , j = right , key = a [ left ]; while ( i < j ) { while ( i < j && key < a [ j ]) j -- ; if ( i < j ) a [ i ++ ] = a [ j ]; while ( i < j && key > a [ i ]) i ++ ; if ( i < j ) a [ j -- ] = a [ i ]; } a [ i ] = key ; quick_sort ( a , left , i - 1 ); quick_sort ( a , i + 1 , right ); } int main () { int N , a [ 100020 ]; cin >> N ; for ( int i = 0 ; i < N ; i ++ ) cin >> a [ i ]; quick_sort ( a , 0 , N - 1 ); for ( int i = 0 ; i < N ; i ++ ) { if ( ! i ) cout << a [ i ]; else cout << ' ' << a [ i ]; } cout << endl ; return 0 ; }","title":"\u5feb\u901f\u6392\u5e8f"},{"location":"\u641c\u7d22/\u5e7f\u5ea6\u4f18\u5148\u641c\u7d22,BFS/","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 #include <iostream> #include <queue> #define INF 99999999 using namespace std ; typedef pair < int , int > P ; char a [ 20 ][ 20 ]; int step [ 500 ][ 500 ]; //\u6b65\u6570 int dir [ 4 ][ 2 ] = {{ 0 , 1 },{ 1 , 0 },{ 0 , - 1 },{ - 1 , 0 }}; int sx = 0 , sy = 0 ; int gx = 2 , gy = 3 ; int bfs (){ queue < P > que ; for ( int i = 0 ; i < 5 ; i ++ ) for ( int j = 0 ; j < 5 ; j ++ ) step [ i ][ j ] = INF ; que . push ( P ( sx , sy )); step [ sx ][ sy ] = 0 ; while ( que . size ()){ P p = que . front (); que . pop (); if ( p . first == gx && p . second == gy ) break ; for ( int i = 0 ; i < 4 ; i ++ ){ int nx = p . first + dir [ i ][ 0 ]; int ny = p . second + dir [ i ][ 1 ]; if ( nx >= 0 && nx < 5 && ny >= 0 && ny < 5 && a [ nx ][ ny ] != '#' && step [ nx ][ ny ] == INF ){ que . push ( P ( nx , ny )); step [ nx ][ ny ] = step [ p . first ][ p . second ] + 1 ; } } } return step [ gx ][ gy ]; } int main (){ for ( int i = 0 ; i < 5 ; i ++ ) for ( int j = 0 ; j < 5 ; j ++ ) cin >> a [ i ][ j ]; int res = bfs (); cout << res ; return 0 ; }","title":"\u5e7f\u5ea6\u4f18\u5148\u641c\u7d22,BFS"},{"location":"\u641c\u7d22/\u6df1\u5ea6\u4f18\u5148\u641c\u7d22,DFS/","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 #include <stdio.h> int n , m , p , q , min = 99999999 ; int a [ 51 ][ 51 ], book [ 51 ][ 51 ]; void dfs ( int x , int y , int step ) { int next [ 4 ][ 2 ] = { { 0 , 1 }, //\u5411\u53f3\u8d70 { 1 , 0 }, //\u5411\u4e0b\u8d70 { 0 , - 1 }, //\u5411\u5de6\u8d70 { - 1 , 0 }, //\u5411\u4e0a\u8d70 }; int tx , ty , k ; if ( x == p && y == q ) //\u5224\u65ad\u662f\u5426\u5230\u8fbe\u5c0f\u54c8\u7684\u4f4d\u7f6e { if ( step < min ) min = step ; //\u66f4\u65b0\u6700\u5c0f\u503c return ; } /*\u679a\u4e3e\u56db\u79cd\u8d70\u6cd5*/ for ( k = 0 ; k <= 3 ; k ++ ) { /*\u8ba1\u7b97\u4e0b\u4e00\u4e2a\u70b9\u7684\u5750\u6807*/ tx = x + next [ k ][ 0 ]; ty = y + next [ k ][ 1 ]; if ( tx < 1 || tx > n || ty < 1 || ty > m ) //\u5224\u65ad\u662f\u5426\u8d8a\u754c continue ; /*\u5224\u65ad\u8be5\u70b9\u662f\u5426\u4e3a\u969c\u788d\u7269\u6216\u8005\u5df2\u7ecf\u5728\u8def\u5f84\u4e2d*/ if ( a [ tx ][ ty ] == 0 && book [ tx ][ ty ] == 0 ) { book [ tx ][ ty ] = 1 ; //\u6807\u8bb0\u8fd9\u4e2a\u70b9\u5df2\u7ecf\u8d70\u8fc7 dfs ( tx , ty , step + 1 ); //\u5f00\u59cb\u5c1d\u8bd5\u4e0b\u4e00\u4e2a\u70b9 book [ tx ][ ty ] = 0 ; //\u5c1d\u8bd5\u7ed3\u675f\uff0c\u53d6\u6d88\u8fd9\u4e2a\u70b9\u7684\u6807\u8bb0 } } return ; } int main () { int i , j , startx , starty ; scanf ( \"%d %d\" , & n , & m ); //\u8bfb\u5165n\u548cm\uff0cn\u4e3a\u884c\uff0cm\u4e3a\u5217 /*\u8bfb\u5165\u8ff7\u5bab*/ for ( i = 1 ; i <= n ; i ++ ) for ( j = 1 ; j <= m ; j ++ ) scanf ( \"%d\" , & a [ i ][ j ]); scanf ( \"%d %d %d %d\" , & startx , & starty , & p , & q ); //\u8bfb\u5165\u8d77\u70b9\u548c\u7ec8\u70b9\u5750\u6807 /*\u4ece\u8d77\u70b9\u5f00\u59cb\u641c\u7d22*/ book [ startx ][ starty ] = 1 ; //\u6807\u8bb0\u8d77\u70b9\u5df2\u7ecf\u5728\u8def\u5f84\u4e2d\uff0c\u9632\u6b62\u540e\u9762\u91cd\u590d\u8d70 dfs ( startx , starty , 0 ); //\u7b2c\u4e00\u4e2a\u53c2\u6570\u662f\u8d77\u70b9\u7684x\u5750\u6807\uff0c\u4ee5\u6b64\u7c7b\u63a8\u662f\u8d77\u70b9\u7684y\u5750\u6807\uff0c\u521d\u59cb\u6b65\u6570\u4e3a0 printf ( \"%d\" , min ); //\u8f93\u51fa\u6700\u77ed\u6b65\u6570 return 0 ; }","title":"\u6df1\u5ea6\u4f18\u5148\u641c\u7d22,DFS"},{"location":"\u6570\u8bba,\u6570\u5b66/\u540c\u4f59,\u4e2d\u56fd\u5269\u4f59\u5b9a\u7406/","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 #include <iostream> typedef long long ll ; using namespace std ; ll yu [ 120 ], chu [ 120 ]; ll exgcd ( ll a , ll b , ll & x , ll & y ) { if ( b == 0 ) { x = 1 , y = 0 ; return a ; } else { ll res = exgcd ( b , a % b , y , x ); y -= x * ( a / b ); return res ; } } ll china ( int l ) { ll d , x , y , m , n = 1 , ret = 0 ; for ( int i = 0 ; i < l ; i ++ ) n *= chu [ i ]; for ( int i = 0 ; i < l ; i ++ ) { m = n / chu [ i ]; d = exgcd ( chu [ i ], m , x , y ); ret = ( ret + y * m * yu [ i ]) % n ; } return ( n + ret % n ) % n ; } int main () { int N ; cin >> N ; for ( int i = 0 ; i < N ; i ++ ) cin >> chu [ i ] >> yu [ i ]; cout << china ( N ) << endl ; return 0 ; }","title":"\u540c\u4f59,\u4e2d\u56fd\u5269\u4f59\u5b9a\u7406"},{"location":"\u6570\u8bba,\u6570\u5b66/\u6269\u5c55\u6b27\u51e0\u91cc\u5f97/","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 ll exgcd ( ll a , ll b , ll & x , ll & y ) { if ( b == 0 ) { x = 1 , y = 0 ; return a ; } else { ll res = exgcd ( b , a % b , y , x ); y -= x * ( a / b ); return res ; } }","title":"\u6269\u5c55\u6b27\u51e0\u91cc\u5f97"},{"location":"\u6570\u8bba,\u6570\u5b66/\u6700\u5927\u516c\u7ea6\u6570,GCD/","text":"1 2 3 4 5 int gcd ( int a , int b ) { if ( b == 0 ) return a ; return gcd ( b , a % b ); }","title":"\u6700\u5927\u516c\u7ea6\u6570,GCD"},{"location":"\u6570\u8bba,\u6570\u5b66/\u9006\u5143/","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 ll exgcd ( ll a , ll b , ll & x , ll & y ) { if ( b == 0 ) { x = 1 , y = 0 ; return a ; } else { ll res = exgcd ( b , a % b , y , x ); y -= x * ( a / b ); return res ; } } ll inv ( ll a , ll n ) { ll x , y ; exgcd ( a , n , x , y ); return ( x % n + n ) % n ; }","title":"\u9006\u5143"},{"location":"\u6811\u5f62\u7ed3\u6784/\u5e76\u67e5\u96c6/","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 #include <iostream> #include <cstdio> #include <cstring> #include <cmath> #include <algorithm> using namespace std ; int pre [ 1010 ]; //\u91cc\u9762\u5168\u662f\u638c\u95e8 int unionsearch ( int root ) { int son , tmp ; son = root ; while ( root != pre [ root ]) //\u5bfb\u627e\u638c\u95e8ing\u2026\u2026 root = pre [ root ]; while ( son != root ) //\u8def\u5f84\u538b\u7f29 { tmp = pre [ son ]; pre [ son ] = root ; son = tmp ; } return root ; //\u638c\u95e8\u9a7e\u5230~ } int main () { int num , road , total , i , start , end , root1 , root2 ; while ( scanf ( \"%d%d\" , & num , & road ) && num ) { total = num - 1 ; //\u5171num-1\u4e2a\u95e8\u6d3e for ( i = 1 ; i <= num ; ++ i ) //\u6bcf\u6761\u8def\u90fd\u662f\u638c\u95e8 pre [ i ] = i ; while ( road -- ) { scanf ( \"%d%d\" , & start , & end ); //\u4ed6\u4fe9\u8981\u7ed3\u62dc root1 = unionsearch ( start ); root2 = unionsearch ( end ); if ( root1 != root2 ) //\u638c\u95e8\u4e0d\u540c\uff1f\u8e22\u9986\uff01~ { pre [ root1 ] = root2 ; total -- ; //\u95e8\u6d3e\u5c11\u4e00\u4e2a\uff0c\u654c\u4eba\uff08\u8981\u5efa\u7684\u8def\uff09\u5c31\u5c11\u4e00\u4e2a } } printf ( \"%d \\n \" , total ); //\u5929\u4e0b\u5c40\u52bf\uff1a\u8fd8\u5269\u51e0\u4e2a\u95e8\u6d3e } return 0 ; }","title":"\u5e76\u67e5\u96c6"},{"location":"\u6811\u5f62\u7ed3\u6784/\u6700\u8fd1\u516c\u5171\u7956\u5148,LCA/","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 #include <cstdio> #include <cstring> #include <iostream> #include <algorithm> #include <vector> #include <cmath> using namespace std ; const int maxn = 4e4 + 50 ; const int logtwo = 30 ; struct edge { int to , w ; edge (){} edge ( int _w , int _to ){ w = _w ; to = _to ; } }; vector < edge > G [ maxn ]; int grand [ maxn ][ logtwo ], depth [ maxn ], gw [ maxn ][ logtwo ]; int n , m , N ; void dfs ( int x ) { for ( int i = 1 ; i <= N ; i ++ ) { grand [ x ][ i ] = grand [ grand [ x ][ i - 1 ]][ i - 1 ]; gw [ x ][ i ] = gw [ grand [ x ][ i - 1 ]][ i - 1 ] + gw [ x ][ i - 1 ]; } int len = G [ x ]. size (); for ( int i = 0 ; i < len ; i ++ ) { edge e = G [ x ][ i ]; if ( grand [ x ][ 0 ] != e . to ) { depth [ e . to ] = depth [ x ] + 1 ; grand [ e . to ][ 0 ] = x ; gw [ e . to ][ 0 ] = e . w ; dfs ( e . to ); } } } void init () { N = floor ( log ( n + 0.0 ) / log ( 2.0 ) ); memset ( depth , 0 , sizeof ( depth )); memset ( grand , 0 , sizeof ( grand )); memset ( gw , 0 , sizeof ( gw )); dfs ( 1 ); } int lca ( int a , int b ) { if ( depth [ a ] > depth [ b ] ) swap ( a , b ); int ans = 0 ; for ( int i = N ; i >= 0 ; i -- ) { if ( depth [ a ] < depth [ b ] && depth [ grand [ b ][ i ]] >= depth [ a ] ) ans += gw [ b ][ i ] , b = grand [ b ][ i ]; } for ( int j = N ; j >= 0 ; j -- ) { if ( grand [ a ][ j ] != grand [ b ][ j ] ) { ans += gw [ a ][ j ]; ans += gw [ b ][ j ]; a = grand [ a ][ j ]; b = grand [ b ][ j ]; } } if ( a != b ) ans += gw [ a ][ 0 ], ans += gw [ b ][ 0 ]; return ans ; } int main (){ int t ; cin >> t ; while ( t -- ) { scanf ( \"%d %d\" , & n , & m ); for ( int i = 0 ; i <= n ; i ++ ) G [ i ]. clear (); int u , v , w ; for ( int i = 0 ; i < n - 1 ; i ++ ) { scanf ( \"%d %d %d\" , & u , & v , & w ); G [ u ]. push_back ( edge ( w , v )); G [ v ]. push_back ( edge ( w , u )); } init (); int a , b ; for ( int i = 1 ; i <= m ; i ++ ) { scanf ( \"%d %d\" , & a , & b ); printf ( \"%d \\n \" , lca ( a , b )); } } return 0 ; } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 #include <cstdio> #include <cstring> #include <iostream> #include <algorithm> using namespace std ; const int maxn = 4e4 + 50 ; const int logtwo = 30 ; struct edge { int nxt , w , to ; } ss [ maxn << 2 ]; int head [ maxn ] , depth [ maxn ] , father [ maxn ][ logtwo ] , fw [ maxn ] ; int n , m , cnt , u , v , w , s1 , s2 ; void init () { cnt = 0 ; memset ( depth , 0 , sizeof ( depth )) ; memset ( fw , 0 , sizeof ( fw )) ; memset ( father , 0 , sizeof ( father )) ; memset ( head , - 1 , sizeof ( head )) ; } void _add ( int u , int v , int w ) { ss [ ++ cnt ]. w = w ; ss [ cnt ]. to = v ; ss [ cnt ]. nxt = head [ u ]; head [ u ] = cnt ; } void add_edge ( int u , int v , int w ) { _add ( u , v , w ) ; _add ( v , u , w ) ; } void dfs ( int x ) { for ( int i = 1 ; ( 1 << i ) <= depth [ x ] ; i ++ ) { father [ x ][ i ] = father [ father [ x ][ i - 1 ]][ i - 1 ]; } for ( int i = head [ x ] ; ~ i ; i = ss [ i ]. nxt ) { int v = ss [ i ]. to ; if ( v != father [ x ][ 0 ] ) { father [ v ][ 0 ] = x ; depth [ v ] = depth [ x ] + 1 ; fw [ v ] = fw [ x ] + ss [ i ]. w ; dfs ( v ) ; } } } int lca ( int a , int b ) { if ( depth [ a ] > depth [ b ] ) swap ( a , b ) ; int dis = depth [ b ] - depth [ a ] ; for ( int i = 0 ; ( 1 << i ) <= dis ; i ++ ) { if ( dis & ( 1 << i ) ) { b = father [ b ][ i ]; } } if ( a == b ) return a ; for ( int i = 29 ; i >= 0 ; i -- ) { if ( father [ a ][ i ] != father [ b ][ i ] ) { a = father [ a ][ i ]; b = father [ b ][ i ]; } } return father [ a ][ 0 ]; } int main () { int t ; cin >> t ; while ( t -- ) { init () ; scanf ( \"%d %d\" , & n , & m ); for ( int i = 1 ; i < n ; i ++ ) { scanf ( \"%d %d %d\" , & u , & v , & w ) ; add_edge ( u , v , w ); } dfs ( 1 ) ; for ( int i = 1 ; i <= m ; i ++ ) { scanf ( \"%d %d\" , & s1 , & s2 ) ; printf ( \"%d \\n \" , fw [ s1 ] + fw [ s2 ] - 2 * fw [ lca ( s1 , s2 )] ); } } return 0 ; }","title":"\u6700\u8fd1\u516c\u5171\u7956\u5148,LCA"},{"location":"\u6811\u5f62\u7ed3\u6784/\u6811\u7684\u76f4\u5f84/","text":"No.1 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 #include <bits/stdc++.h> const int maxn = 100020 ; using namespace std ; int dis [ maxn ], ans ; bool vis [ maxn ]; vector < pair < int , int > > V [ maxn ]; int bfs ( int x ) { memset ( dis , 0 , sizeof ( dis )); memset ( vis , 0 , sizeof ( vis )); queue < int > Q ; Q . push ( x ); vis [ x ] = 1 ; int point = 0 ; while ( ! Q . empty ()) { int F = Q . front (); Q . pop (); if ( dis [ F ] > ans ) { ans = dis [ F ]; point = F ; } pair < int , int > t ; for ( int i = 0 ; i < V [ F ]. size (); i ++ ) { t = V [ F ][ i ]; if ( vis [ t . first ] == 0 ) { vis [ t . first ] = 1 ; dis [ t . first ] = dis [ F ] + t . second ; Q . push ( t . first ); } } } return point ; } int main () { int N , M , x , y , z ; char dir ; while ( cin >> N >> M ) { for ( int i = 0 ; i < M ; i ++ ) { cin >> x >> y >> z >> dir ; V [ x ]. push_back ( make_pair ( y , z )); V [ y ]. push_back ( make_pair ( x , z )); } ans = 0 ; int point = bfs ( 1 ); ans = 0 ; bfs ( point ); cout << ans << endl ; for ( int i = 0 ; i <= N ; i ++ ) V [ i ]. clear (); } return 0 ; } No.2 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 #include <bits/stdc++.h> using namespace std ; char MAP [ 1020 ][ 1020 ]; int dx [ 4 ] = { - 1 , 0 , 1 , 0 }; int dy [ 4 ] = { 0 , 1 , 0 , - 1 }; int dis [ 1020 ][ 1020 ]; int N , M , fx , fy ; int bfs ( int x , int y ) { int ans = 0 ; memset ( dis , - 1 , sizeof ( dis )); queue < int > Q ; Q . push ( x ); Q . push ( y ); dis [ x ][ y ] = 0 ; while ( ! Q . empty ()) { x = Q . front (); Q . pop (); y = Q . front (); Q . pop (); for ( int i = 0 ; i < 4 ; i ++ ) { int nx = dx [ i ] + x ; int ny = dy [ i ] + y ; if ( nx >= 0 && nx < M && ny >= 0 && ny < N && MAP [ nx ][ ny ] == '.' && dis [ nx ][ ny ] ==- 1 ) { Q . push ( nx ); Q . push ( ny ); dis [ nx ][ ny ] = dis [ x ][ y ] + 1 ; if ( ans < dis [ nx ][ ny ]) { ans = dis [ nx ][ ny ]; fx = nx ; fy = ny ; } } } } return ans ; } int main () { int T ; scanf ( \"%d\" , & T ); while ( T -- ) { scanf ( \"%d%d\" , & N , & M ); bool flag = 0 ; for ( int i = 0 ; i < M ; i ++ ) scanf ( \"%s\" , MAP [ i ]); for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < M ; j ++ ) { if ( MAP [ i ][ j ] == '.' ) { fx = i , fy = j ; flag = 1 ; break ; } } if ( flag ) break ; } bfs ( fx , fy ); printf ( \"Maximum rope length is %d. \\n \" , bfs ( fx , fy )); } return 0 ; }","title":"\u6811\u7684\u76f4\u5f84"},{"location":"\u6811\u5f62\u7ed3\u6784/\u7ebf\u6bb5\u6811/","text":"\u7ebf\u6bb5\u6811\u529f\u80fd:update:\u5355\u70b9\u589e\u51cf query:\u533a\u95f4\u6c42\u548c 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 #include <cstdio> #define lson l , m , rt << 1 #define rson m + 1 , r , rt << 1 | 1 const int maxn = 55555 ; int sum [ maxn << 2 ]; void PushUP ( int rt ) { sum [ rt ] = sum [ rt << 1 ] + sum [ rt << 1 | 1 ]; } void build ( int l , int r , int rt ) { if ( l == r ) { scanf ( \"%d\" , & sum [ rt ]); return ; } int m = ( l + r ) >> 1 ; build ( lson ); build ( rson ); PushUP ( rt ); } void update ( int p , int add , int l , int r , int rt ) { if ( l == r ) { sum [ rt ] += add ; return ; } int m = ( l + r ) >> 1 ; if ( p <= m ) update ( p , add , lson ); else update ( p , add , rson ); PushUP ( rt ); } int query ( int L , int R , int l , int r , int rt ) { if ( L <= l && r <= R ) { return sum [ rt ]; } int m = ( l + r ) >> 1 ; int ret = 0 ; if ( L <= m ) ret += query ( L , R , lson ); if ( R > m ) ret += query ( L , R , rson ); return ret ; } int main () { int T , n ; scanf ( \"%d\" , & T ); for ( int cas = 1 ; cas <= T ; cas ++ ) { printf ( \"Case %d: \\n \" , cas ); scanf ( \"%d\" , & n ); build ( 1 , n , 1 ); char op [ 10 ]; while ( scanf ( \"%s\" , op )) { if ( op [ 0 ] == 'E' ) break ; int a , b ; scanf ( \"%d%d\" , & a , & b ); if ( op [ 0 ] == 'Q' ) printf ( \"%d \\n \" , query ( a , b , 1 , n , 1 )); else if ( op [ 0 ] == 'S' ) update ( a , - b , 1 , n , 1 ); else update ( a , b , 1 , n , 1 ); } } return 0 ; } \u7ebf\u6bb5\u6811\u529f\u80fd:update:\u5355\u70b9\u66ff\u6362 query:\u533a\u95f4\u6700\u503c 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 #include <cstdio> #include <algorithm> using namespace std ; #define lson l , m , rt << 1 #define rson m + 1 , r , rt << 1 | 1 const int maxn = 222222 ; int MAX [ maxn << 2 ]; void PushUP ( int rt ) { MAX [ rt ] = max ( MAX [ rt << 1 ] , MAX [ rt << 1 | 1 ]); } void build ( int l , int r , int rt ) { if ( l == r ) { scanf ( \"%d\" , & MAX [ rt ]); return ; } int m = ( l + r ) >> 1 ; build ( lson ); build ( rson ); PushUP ( rt ); } void update ( int p , int sc , int l , int r , int rt ) { if ( l == r ) { MAX [ rt ] = sc ; return ; } int m = ( l + r ) >> 1 ; if ( p <= m ) update ( p , sc , lson ); else update ( p , sc , rson ); PushUP ( rt ); } int query ( int L , int R , int l , int r , int rt ) { if ( L <= l && r <= R ) { return MAX [ rt ]; } int m = ( l + r ) >> 1 ; int ret = 0 ; if ( L <= m ) ret = max ( ret , query ( L , R , lson )); if ( R > m ) ret = max ( ret , query ( L , R , rson )); return ret ; } int main () { int n , m ; while ( ~ scanf ( \"%d%d\" , & n , & m )) { build ( 1 , n , 1 ); while ( m -- ) { char op [ 2 ]; int a , b ; scanf ( \"%s%d%d\" , op , & a , & b ); if ( op [ 0 ] == 'Q' ) printf ( \"%d \\n \" , query ( a , b , 1 , n , 1 )); else update ( a , b , 1 , n , 1 ); } } return 0 ; } \u7ebf\u6bb5\u6811\u529f\u80fd:update:\u5355\u70b9\u589e\u51cf query:\u533a\u95f4\u6c42\u548c 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 #include <cstdio> #include <algorithm> using namespace std ; #define lson l , m , rt << 1 #define rson m + 1 , r , rt << 1 | 1 const int maxn = 5555 ; int sum [ maxn << 2 ]; void PushUP ( int rt ) { sum [ rt ] = sum [ rt << 1 ] + sum [ rt << 1 | 1 ]; } void build ( int l , int r , int rt ) { sum [ rt ] = 0 ; if ( l == r ) return ; int m = ( l + r ) >> 1 ; build ( lson ); build ( rson ); } void update ( int p , int l , int r , int rt ) { if ( l == r ) { sum [ rt ] ++ ; return ; } int m = ( l + r ) >> 1 ; if ( p <= m ) update ( p , lson ); else update ( p , rson ); PushUP ( rt ); } int query ( int L , int R , int l , int r , int rt ) { if ( L <= l && r <= R ) { return sum [ rt ]; } int m = ( l + r ) >> 1 ; int ret = 0 ; if ( L <= m ) ret += query ( L , R , lson ); if ( R > m ) ret += query ( L , R , rson ); return ret ; } int x [ maxn ]; int main () { int n ; while ( ~ scanf ( \"%d\" , & n )) { build ( 0 , n - 1 , 1 ); int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { scanf ( \"%d\" , & x [ i ]); sum += query ( x [ i ] , n - 1 , 0 , n - 1 , 1 ); update ( x [ i ] , 0 , n - 1 , 1 ); } int ret = sum ; for ( int i = 0 ; i < n ; i ++ ) { sum += n - x [ i ] - x [ i ] - 1 ; ret = min ( ret , sum ); } printf ( \"%d \\n \" , ret ); } return 0 ; } \u7ebf\u6bb5\u6811\u529f\u80fd:query:\u533a\u95f4\u6c42\u6700\u5927\u503c\u7684\u4f4d\u5b50(\u76f4\u63a5\u628aupdate\u7684\u64cd\u4f5c\u5728query\u91cc\u505a\u4e86) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 #include <cstdio> #include <algorithm> using namespace std ; #define lson l , m , rt << 1 #define rson m + 1 , r , rt << 1 | 1 const int maxn = 222222 ; int h , w , n ; int MAX [ maxn << 2 ]; void PushUP ( int rt ) { MAX [ rt ] = max ( MAX [ rt << 1 ] , MAX [ rt << 1 | 1 ]); } void build ( int l , int r , int rt ) { MAX [ rt ] = w ; if ( l == r ) return ; int m = ( l + r ) >> 1 ; build ( lson ); build ( rson ); } int query ( int x , int l , int r , int rt ) { if ( l == r ) { MAX [ rt ] -= x ; return l ; } int m = ( l + r ) >> 1 ; int ret = ( MAX [ rt << 1 ] >= x ) ? query ( x , lson ) : query ( x , rson ); PushUP ( rt ); return ret ; } int main () { while ( ~ scanf ( \"%d%d%d\" , & h , & w , & n )) { if ( h > n ) h = n ; build ( 1 , h , 1 ); while ( n -- ) { int x ; scanf ( \"%d\" , & x ); if ( MAX [ 1 ] < x ) puts ( \"-1\" ); else printf ( \"%d \\n \" , query ( x , 1 , h , 1 )); } } return 0 ; } \u7ebf\u6bb5\u6811\u529f\u80fd:update:\u6210\u6bb5\u66ff\u6362 (\u7531\u4e8e\u53eaquery\u4e00\u6b21\u603b\u533a\u95f4,\u6240\u4ee5\u53ef\u4ee5\u76f4\u63a5\u8f93\u51fa1\u7ed3\u70b9\u7684\u4fe1\u606f) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 #include <cstdio> #include <algorithm> using namespace std ; #define lson l , m , rt << 1 #define rson m + 1 , r , rt << 1 | 1 const int maxn = 111111 ; int h , w , n ; int col [ maxn << 2 ]; int sum [ maxn << 2 ]; void PushUp ( int rt ) { sum [ rt ] = sum [ rt << 1 ] + sum [ rt << 1 | 1 ]; } void PushDown ( int rt , int m ) { if ( col [ rt ]) { col [ rt << 1 ] = col [ rt << 1 | 1 ] = col [ rt ]; sum [ rt << 1 ] = ( m - ( m >> 1 )) * col [ rt ]; sum [ rt << 1 | 1 ] = ( m >> 1 ) * col [ rt ]; col [ rt ] = 0 ; } } void build ( int l , int r , int rt ) { col [ rt ] = 0 ; sum [ rt ] = 1 ; if ( l == r ) return ; int m = ( l + r ) >> 1 ; build ( lson ); build ( rson ); PushUp ( rt ); } void update ( int L , int R , int c , int l , int r , int rt ) { if ( L <= l && r <= R ) { col [ rt ] = c ; sum [ rt ] = c * ( r - l + 1 ); return ; } PushDown ( rt , r - l + 1 ); int m = ( l + r ) >> 1 ; if ( L <= m ) update ( L , R , c , lson ); if ( R > m ) update ( L , R , c , rson ); PushUp ( rt ); } int main () { int T , n , m ; scanf ( \"%d\" , & T ); for ( int cas = 1 ; cas <= T ; cas ++ ) { scanf ( \"%d%d\" , & n , & m ); build ( 1 , n , 1 ); while ( m -- ) { int a , b , c ; scanf ( \"%d%d%d\" , & a , & b , & c ); update ( a , b , c , 1 , n , 1 ); } printf ( \"Case %d: The total value of the hook is %d. \\n \" , cas , sum [ 1 ]); } return 0 ; } \u7ebf\u6bb5\u6811\u529f\u80fd:update:\u6210\u6bb5\u589e\u51cf query:\u533a\u95f4\u6c42\u548c 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 #include <cstdio> #include <algorithm> using namespace std ; #define lson l , m , rt << 1 #define rson m + 1 , r , rt << 1 | 1 #define LL long long const int maxn = 111111 ; LL add [ maxn << 2 ]; LL sum [ maxn << 2 ]; void PushUp ( int rt ) { sum [ rt ] = sum [ rt << 1 ] + sum [ rt << 1 | 1 ]; } void PushDown ( int rt , int m ) { if ( add [ rt ]) { add [ rt << 1 ] += add [ rt ]; add [ rt << 1 | 1 ] += add [ rt ]; sum [ rt << 1 ] += add [ rt ] * ( m - ( m >> 1 )); sum [ rt << 1 | 1 ] += add [ rt ] * ( m >> 1 ); add [ rt ] = 0 ; } } void build ( int l , int r , int rt ) { add [ rt ] = 0 ; if ( l == r ) { scanf ( \"%lld\" , & sum [ rt ]); return ; } int m = ( l + r ) >> 1 ; build ( lson ); build ( rson ); PushUp ( rt ); } void update ( int L , int R , int c , int l , int r , int rt ) { if ( L <= l && r <= R ) { add [ rt ] += c ; sum [ rt ] += ( LL ) c * ( r - l + 1 ); return ; } PushDown ( rt , r - l + 1 ); int m = ( l + r ) >> 1 ; if ( L <= m ) update ( L , R , c , lson ); if ( m < R ) update ( L , R , c , rson ); PushUp ( rt ); } LL query ( int L , int R , int l , int r , int rt ) { if ( L <= l && r <= R ) { return sum [ rt ]; } PushDown ( rt , r - l + 1 ); int m = ( l + r ) >> 1 ; LL ret = 0 ; if ( L <= m ) ret += query ( L , R , lson ); if ( m < R ) ret += query ( L , R , rson ); return ret ; } int main () { int N , Q ; scanf ( \"%d%d\" , & N , & Q ); build ( 1 , N , 1 ); while ( Q -- ) { char op [ 2 ]; int a , b , c ; scanf ( \"%s\" , op ); if ( op [ 0 ] == 'Q' ) { scanf ( \"%d%d\" , & a , & b ); printf ( \"%lld \\n \" , query ( a , b , 1 , N , 1 )); } else { scanf ( \"%d%d%d\" , & a , & b , & c ); update ( a , b , c , 1 , N , 1 ); } } return 0 ; } \u7ebf\u6bb5\u6811\u529f\u80fd:update:\u6210\u6bb5\u66ff\u6362 query:\u7b80\u5355hash 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 #include <cstdio> #include <cstring> #include <algorithm> using namespace std ; #define lson l , m , rt << 1 #define rson m + 1 , r , rt << 1 | 1 const int maxn = 11111 ; bool hash [ maxn ]; int li [ maxn ] , ri [ maxn ]; int X [ maxn * 3 ]; int col [ maxn << 4 ]; int cnt ; void PushDown ( int rt ) { if ( col [ rt ] != - 1 ) { col [ rt << 1 ] = col [ rt << 1 | 1 ] = col [ rt ]; col [ rt ] = - 1 ; } } void update ( int L , int R , int c , int l , int r , int rt ) { if ( L <= l && r <= R ) { col [ rt ] = c ; return ; } PushDown ( rt ); int m = ( l + r ) >> 1 ; if ( L <= m ) update ( L , R , c , lson ); if ( m < R ) update ( L , R , c , rson ); } void query ( int l , int r , int rt ) { if ( col [ rt ] != - 1 ) { if ( ! hash [ col [ rt ]]) cnt ++ ; hash [ col [ rt ] ] = true ; return ; } if ( l == r ) return ; int m = ( l + r ) >> 1 ; query ( lson ); query ( rson ); } int Bin ( int key , int n , int X []) { int l = 0 , r = n - 1 ; while ( l <= r ) { int m = ( l + r ) >> 1 ; if ( X [ m ] == key ) return m ; if ( X [ m ] < key ) l = m + 1 ; else r = m - 1 ; } return - 1 ; } int main () { int T , n ; scanf ( \"%d\" , & T ); while ( T -- ) { scanf ( \"%d\" , & n ); int nn = 0 ; for ( int i = 0 ; i < n ; i ++ ) { scanf ( \"%d%d\" , & li [ i ] , & ri [ i ]); X [ nn ++ ] = li [ i ]; X [ nn ++ ] = ri [ i ]; } sort ( X , X + nn ); int m = 1 ; for ( int i = 1 ; i < nn ; i ++ ) { if ( X [ i ] != X [ i - 1 ]) X [ m ++ ] = X [ i ]; } for ( int i = m - 1 ; i > 0 ; i -- ) { if ( X [ i ] != X [ i - 1 ] + 1 ) X [ m ++ ] = X [ i ] + 1 ; } sort ( X , X + m ); memset ( col , - 1 , sizeof ( col )); for ( int i = 0 ; i < n ; i ++ ) { int l = Bin ( li [ i ] , m , X ); int r = Bin ( ri [ i ] , m , X ); update ( l , r , i , 0 , m , 1 ); } cnt = 0 ; memset ( hash , false , sizeof ( hash )); query ( 0 , m , 1 ); printf ( \"%d \\n \" , cnt ); } return 0 ; } \u7ebf\u6bb5\u6811\u529f\u80fd:update:\u6210\u6bb5\u66ff\u6362,\u533a\u95f4\u5f02\u6216 query:\u7b80\u5355hash 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 #include <cstdio> #include <cstring> #include <cctype> #include <algorithm> using namespace std ; #define lson l , m , rt << 1 #define rson m + 1 , r , rt << 1 | 1 const int maxn = 131072 ; bool hash [ maxn ]; int cover [ maxn << 2 ]; int XOR [ maxn << 2 ]; void FXOR ( int rt ) { if ( cover [ rt ] != - 1 ) cover [ rt ] ^= 1 ; else XOR [ rt ] ^= 1 ; } void PushDown ( int rt ) { if ( cover [ rt ] != - 1 ) { cover [ rt << 1 ] = cover [ rt << 1 | 1 ] = cover [ rt ]; XOR [ rt << 1 ] = XOR [ rt << 1 | 1 ] = 0 ; cover [ rt ] = - 1 ; } if ( XOR [ rt ]) { FXOR ( rt << 1 ); FXOR ( rt << 1 | 1 ); XOR [ rt ] = 0 ; } } void update ( char op , int L , int R , int l , int r , int rt ) { if ( L <= l && r <= R ) { if ( op == 'U' ) { cover [ rt ] = 1 ; XOR [ rt ] = 0 ; } else if ( op == 'D' ) { cover [ rt ] = 0 ; XOR [ rt ] = 0 ; } else if ( op == 'C' || op == 'S' ) { FXOR ( rt ); } return ; } PushDown ( rt ); int m = ( l + r ) >> 1 ; if ( L <= m ) update ( op , L , R , lson ); else if ( op == 'I' || op == 'C' ) { XOR [ rt << 1 ] = cover [ rt << 1 ] = 0 ; } if ( m < R ) update ( op , L , R , rson ); else if ( op == 'I' || op == 'C' ) { XOR [ rt << 1 | 1 ] = cover [ rt << 1 | 1 ] = 0 ; } } void query ( int l , int r , int rt ) { if ( cover [ rt ] == 1 ) { for ( int it = l ; it <= r ; it ++ ) { hash [ it ] = true ; } return ; } else if ( cover [ rt ] == 0 ) return ; if ( l == r ) return ; PushDown ( rt ); int m = ( l + r ) >> 1 ; query ( lson ); query ( rson ); } int main () { cover [ 1 ] = XOR [ 1 ] = 0 ; char op , l , r ; int a , b ; while ( ~ scanf ( \"%c %c%d,%d%c \\n \" , & op , & l , & a , & b , & r ) ) { a <<= 1 , b <<= 1 ; if ( l == '(' ) a ++ ; if ( r == ')' ) b -- ; if ( a > b ) { if ( op == 'C' || op == 'I' ) { cover [ 1 ] = XOR [ 1 ] = 0 ; } } else update ( op , a , b , 0 , maxn , 1 ); } query ( 0 , maxn , 1 ); bool flag = false ; int s = - 1 , e ; for ( int i = 0 ; i <= maxn ; i ++ ) { if ( hash [ i ]) { if ( s == - 1 ) s = i ; e = i ; } else { if ( s != - 1 ) { if ( flag ) printf ( \" \" ); flag = true ; printf ( \"%c%d,%d%c\" , s & 1 ? '(' : '[' , s >> 1 , ( e + 1 ) >> 1 , e & 1 ? ')' : ']' ); s = - 1 ; } } } if ( ! flag ) printf ( \"empty set\" ); puts ( \"\" ); return 0 ; } \u7ebf\u6bb5\u6811\u64cd\u4f5c:update:\u533a\u95f4\u66ff\u6362 query:\u8be2\u95ee\u6ee1\u8db3\u6761\u4ef6\u7684\u6700\u5de6\u65ad\u70b9 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 #include <cstdio> #include <cstring> #include <cctype> #include <algorithm> using namespace std ; #define lson l , m , rt << 1 #define rson m + 1 , r , rt << 1 | 1 const int maxn = 55555 ; int lsum [ maxn << 2 ] , rsum [ maxn << 2 ] , msum [ maxn << 2 ]; int cover [ maxn << 2 ]; void PushDown ( int rt , int m ) { if ( cover [ rt ] != - 1 ) { cover [ rt << 1 ] = cover [ rt << 1 | 1 ] = cover [ rt ]; msum [ rt << 1 ] = lsum [ rt << 1 ] = rsum [ rt << 1 ] = cover [ rt ] ? 0 : m - ( m >> 1 ); msum [ rt << 1 | 1 ] = lsum [ rt << 1 | 1 ] = rsum [ rt << 1 | 1 ] = cover [ rt ] ? 0 : ( m >> 1 ); cover [ rt ] = - 1 ; } } void PushUp ( int rt , int m ) { lsum [ rt ] = lsum [ rt << 1 ]; rsum [ rt ] = rsum [ rt << 1 | 1 ]; if ( lsum [ rt ] == m - ( m >> 1 )) lsum [ rt ] += lsum [ rt << 1 | 1 ]; if ( rsum [ rt ] == ( m >> 1 )) rsum [ rt ] += rsum [ rt << 1 ]; msum [ rt ] = max ( lsum [ rt << 1 | 1 ] + rsum [ rt << 1 ] , max ( msum [ rt << 1 ] , msum [ rt << 1 | 1 ])); } void build ( int l , int r , int rt ) { msum [ rt ] = lsum [ rt ] = rsum [ rt ] = r - l + 1 ; cover [ rt ] = - 1 ; if ( l == r ) return ; int m = ( l + r ) >> 1 ; build ( lson ); build ( rson ); } void update ( int L , int R , int c , int l , int r , int rt ) { if ( L <= l && r <= R ) { msum [ rt ] = lsum [ rt ] = rsum [ rt ] = c ? 0 : r - l + 1 ; cover [ rt ] = c ; return ; } PushDown ( rt , r - l + 1 ); int m = ( l + r ) >> 1 ; if ( L <= m ) update ( L , R , c , lson ); if ( m < R ) update ( L , R , c , rson ); PushUp ( rt , r - l + 1 ); } int query ( int w , int l , int r , int rt ) { if ( l == r ) return l ; PushDown ( rt , r - l + 1 ); int m = ( l + r ) >> 1 ; if ( msum [ rt << 1 ] >= w ) return query ( w , lson ); else if ( rsum [ rt << 1 ] + lsum [ rt << 1 | 1 ] >= w ) return m - rsum [ rt << 1 ] + 1 ; return query ( w , rson ); } int main () { int n , m ; scanf ( \"%d%d\" , & n , & m ); build ( 1 , n , 1 ); while ( m -- ) { int op , a , b ; scanf ( \"%d\" , & op ); if ( op == 1 ) { scanf ( \"%d\" , & a ); if ( msum [ 1 ] < a ) puts ( \"0\" ); else { int p = query ( a , 1 , n , 1 ); printf ( \"%d \\n \" , p ); update ( p , p + a - 1 , 1 , 1 , n , 1 ); } } else { scanf ( \"%d%d\" , & a , & b ); update ( a , a + b - 1 , 0 , 1 , n , 1 ); } } return 0 ; } \u7ebf\u6bb5\u6811\u64cd\u4f5c:update:\u533a\u95f4\u589e\u51cf query:\u76f4\u63a5\u53d6\u6839\u8282\u70b9\u7684\u503c 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 #include <cstdio> #include <cstring> #include <cctype> #include <algorithm> using namespace std ; #define lson l , m , rt << 1 #define rson m + 1 , r , rt << 1 | 1 const int maxn = 2222 ; int cnt [ maxn << 2 ]; double sum [ maxn << 2 ]; double X [ maxn ]; struct Seg { double h , l , r ; int s ; Seg (){} Seg ( double a , double b , double c , int d ) : l ( a ) , r ( b ) , h ( c ) , s ( d ) {} bool operator < ( const Seg & cmp ) const { return h < cmp . h ; } } ss [ maxn ]; void PushUp ( int rt , int l , int r ) { if ( cnt [ rt ]) sum [ rt ] = X [ r + 1 ] - X [ l ]; else if ( l == r ) sum [ rt ] = 0 ; else sum [ rt ] = sum [ rt << 1 ] + sum [ rt << 1 | 1 ]; } void update ( int L , int R , int c , int l , int r , int rt ) { if ( L <= l && r <= R ) { cnt [ rt ] += c ; PushUp ( rt , l , r ); return ; } int m = ( l + r ) >> 1 ; if ( L <= m ) update ( L , R , c , lson ); if ( m < R ) update ( L , R , c , rson ); PushUp ( rt , l , r ); } int Bin ( double key , int n , double X []) { int l = 0 , r = n - 1 ; while ( l <= r ) { int m = ( l + r ) >> 1 ; if ( X [ m ] == key ) return m ; if ( X [ m ] < key ) l = m + 1 ; else r = m - 1 ; } return - 1 ; } int main () { int n , cas = 1 ; while ( ~ scanf ( \"%d\" , & n ) && n ) { int m = 0 ; while ( n -- ) { double a , b , c , d ; scanf ( \"%lf%lf%lf%lf\" , & a , & b , & c , & d ); X [ m ] = a ; ss [ m ++ ] = Seg ( a , c , b , 1 ); X [ m ] = c ; ss [ m ++ ] = Seg ( a , c , d , - 1 ); } sort ( X , X + m ); sort ( ss , ss + m ); int k = 1 ; for ( int i = 1 ; i < m ; i ++ ) { if ( X [ i ] != X [ i - 1 ]) X [ k ++ ] = X [ i ]; } memset ( cnt , 0 , sizeof ( cnt )); memset ( sum , 0 , sizeof ( sum )); double ret = 0 ; for ( int i = 0 ; i < m - 1 ; i ++ ) { int l = Bin ( ss [ i ]. l , k , X ); int r = Bin ( ss [ i ]. r , k , X ) - 1 ; if ( l <= r ) update ( l , r , ss [ i ]. s , 0 , k - 1 , 1 ); ret += sum [ 1 ] * ( ss [ i + 1 ]. h - ss [ i ]. h ); } printf ( \"Test case #%d \\n Total explored area: %.2lf \\n\\n \" , cas ++ , ret ); } return 0 ; } \u7ebf\u6bb5\u6811\u64cd\u4f5c:update:\u533a\u95f4\u589e\u51cf query:\u76f4\u63a5\u53d6\u6839\u8282\u70b9\u7684\u503c 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 #include <cstdio> #include <cstring> #include <cctype> #include <algorithm> using namespace std ; #define lson l , m , rt << 1 #define rson m + 1 , r , rt << 1 | 1 const int maxn = 22222 ; struct Seg { int l , r , h , s ; Seg () {} Seg ( int a , int b , int c , int d ) : l ( a ) , r ( b ) , h ( c ) , s ( d ) {} bool operator < ( const Seg & cmp ) const { return h < cmp . h ; } } ss [ maxn ]; bool lbd [ maxn << 2 ] , rbd [ maxn << 2 ]; int numseg [ maxn << 2 ]; int cnt [ maxn << 2 ]; int len [ maxn << 2 ]; void PushUP ( int rt , int l , int r ) { if ( cnt [ rt ]) { lbd [ rt ] = rbd [ rt ] = 1 ; len [ rt ] = r - l + 1 ; numseg [ rt ] = 2 ; } else if ( l == r ) { len [ rt ] = numseg [ rt ] = lbd [ rt ] = rbd [ rt ] = 0 ; } else { lbd [ rt ] = lbd [ rt << 1 ]; rbd [ rt ] = rbd [ rt << 1 | 1 ]; len [ rt ] = len [ rt << 1 ] + len [ rt << 1 | 1 ]; numseg [ rt ] = numseg [ rt << 1 ] + numseg [ rt << 1 | 1 ]; if ( lbd [ rt << 1 | 1 ] && rbd [ rt << 1 ]) numseg [ rt ] -= 2 ; //\u4e24\u6761\u7ebf\u91cd\u5408 } } void update ( int L , int R , int c , int l , int r , int rt ) { if ( L <= l && r <= R ) { cnt [ rt ] += c ; PushUP ( rt , l , r ); return ; } int m = ( l + r ) >> 1 ; if ( L <= m ) update ( L , R , c , lson ); if ( m < R ) update ( L , R , c , rson ); PushUP ( rt , l , r ); } int main () { int n ; while ( ~ scanf ( \"%d\" , & n )) { int m = 0 ; int lbd = 10000 , rbd = - 10000 ; for ( int i = 0 ; i < n ; i ++ ) { int a , b , c , d ; scanf ( \"%d%d%d%d\" , & a , & b , & c , & d ); lbd = min ( lbd , a ); rbd = max ( rbd , c ); ss [ m ++ ] = Seg ( a , c , b , 1 ); ss [ m ++ ] = Seg ( a , c , d , - 1 ); } sort ( ss , ss + m ); int ret = 0 , last = 0 ; for ( int i = 0 ; i < m ; i ++ ) { if ( ss [ i ]. l < ss [ i ]. r ) update ( ss [ i ]. l , ss [ i ]. r - 1 , ss [ i ]. s , lbd , rbd - 1 , 1 ); ret += numseg [ 1 ] * ( ss [ i + 1 ]. h - ss [ i ]. h ); ret += abs ( len [ 1 ] - last ); last = len [ 1 ]; } printf ( \"%d \\n \" , ret ); } return 0 ; }","title":"\u7ebf\u6bb5\u6811"}]}